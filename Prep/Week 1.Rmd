---
title: "SIOB 296 Introduction to Programming with R"
author: "Eric Archer (eric.archer@noaa.gov)"
date: "Week 1: April 4, 2017"
output: pdf_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = TRUE,
	warning = TRUE,
	error = TRUE,
	comment = NA
)
```

## Reading
The Book of R:  
  Chapter 1, pages 3-5 (installing R)  
  Chapter 2 (Numeric, Arithmetic, Assignment and Vectors)  
  Chapter 4 (Non-Numeric Values)  
  Chapter 6, pages 103-114 (Some Special Values)  

## R Console
* commands and assignments executed or evaluated immediately
* separated by new line (Enter/Return) or semicolon
* recall commands with ↑ or ↓
* case sensitive

**NB: EVERY command is executing some function and returns something**


## Help
There are several ways of getting help. The most common is just the `help` command:
```{r}
help(mean)
```

This can be shortened to just `?` in most cases:
```{r}
?median
```

For some special functions, topics, or operators, you should use quotes:
```{r}
help("[") 
```

The examples in help pages can be run using the `example` function:
```{r}
example(mean)
```

Finally, if you don't know the name of the function, but you know a keyword, you can use `help.search`:
```{r}
help.search("regression")
```

## Workspace
The contents of the workspace can be viewed with `ls`:
```{r}
ls()
```

**Useful workspace functions**  
`rm()`: remove an object  
`rm(list = ls())`: remove all objects in the workspace  
`save.image()`: save all objects in the workspace  
`load(".rdata")`: load saved workspace  
`history()`: view saved history  
`#`: comment  

## Math
The R console can be used as a powerful calculator where both complex and simple calculations can be made on the fly:
```{r}
4 + 5
5 / 23
1 / 1.6 + 1
(-5 + sqrt(5 ^ 2 - (4 * 3 * 2))) / (2 * 3)
```

Other common mathematical operators can be found with `?Arithmetic`.

## Data structures
There are six basic storage **modes** that you will encounter in most of your R work:  
`logical`: TRUE, FALSE, T, F  
`integer`: whole numbers (e.g., 1, -1, 15, 0)  
`double`: double precision decimals (e.g., 3.14, 1e-5, 2.0)  
`character`: character strings (e.g., "Hello World", "I love R", "22.3")  
`list`: A collection of objects that can be of different modes  
`function`: A set of commands initiated by a call that takes arguments and returns a value  

  
There are six basic object **classes** that you should become familiar with:  
`vector`: One dimensional, all elements are of same mode  
`factor`: One dimensional, categorical data represented by integers mapped to levels  
`matrix`: Two dimensional, all elements are of same mode  
`array`: Multi-dimensional, all elements are of same mode  
`list`: One dimensional, elements can be of different modes  
`data.frame`: Two dimensional, each column is an element of same length (rows)  

  
**Special Values**  
`NULL`: Empty object or object does not exist 
`NA`: Missing data  
`NaN`: Not a Number (0/0)  
Inf / -Inf: Infinity (1/0)  

**Object Information**  
`str`: Display the structure of an object   
`mode`: The storage mode of an object   
`class`: The class of an object   
`is.<class>`: Test if an object is of a given class   

## Vectors
Objects are assigned values using the "left arrow" (`<-`) operator, like this:
```{r}
x <- 1
x
```

You can also use `=` for assignment, but I seriously recommend not getting into the habit of doing that. It can actually make code harder to read because `=` is used in a slightly different context. I have found it better to be consistent and stick with `<-`.
```{r}
# The ':' operator creates a numeric vector incrementing by 1
x <- 1:10
x

# The `c` function creates a vector containing the arguments inside
y <- c("a", "b", "d")
y

str(x)
is.numeric(x)
class(y)
mode(x)
```

## Indexing
There are three ways to index any object in R:  
**Numeric**: Using integers to reference the element number  
**Character**: If the object has "names", using characters to specify those names  
**Logical**: Return only the elements that match `TRUE` values  

### Numeric Indexing
```{r}
x <- 21:30
x

# The fifth element
x[5]

# The first three elements
x[1:3]

# The first, fifth, and sixth elements
x[c(1, 5, 6)]

# Numerical indexing returns elements in the order they were requested
x[c(8, 9, 3)]

# Replication of elements is allowed and will be acommodated
x[c(4, 6, 5, 6, 4)]

# Any numeric vector is allowed
x[c(1:4, 5, 10:8)]

# Negative numbers return all elements except the negative value
x[-3]

# Don't fall into this trap
x[-1:5]

# What you probably mean is this
x[-(1:5)]
```

### Character Indexing
To use character indexing, you have to provide `names` to the vector
```{r}
names(x) <- letters[1:10]
x

str(x)
```

Then, elements can be specified by name
```{r}
x["d"]

x[c("f", "a")]
```

Specific names can be changed by referencing the `names(x)` vector
```{r}
names(x)[4] <- "fourth"
x["fourth"]
```


### Logical indexing
The third way to index is using logical vectors. Only elements matching `TRUE` values are returned

```{r}
y <- 1:4
y[c(T, T, F, T)]
```

Here are the primary logical operators:  
`!` : Not - negates the value (!T = F, !F = T)  
`&` : And - Result is T if both values are T (T & T = T, T & F = F, F & F = F)  
`|` : Or - Result is T if one value is T (T | T = T, T | F = T, F | F = F)  
`<`, `>` : Less, greater than  
`<=`, `>=` : Less than or equal to, greater than or equal to  
`==` : Equal to  
`!=` : Not equal to  
`any()` : Returns T if any value is T  
`all()` : Returns T if all values are T  

```{r}
x <- 50:20
x
x[x < 30]

x[x < 40 & x > 25]

x[x < 25 | x > 43]
```


## Vectorization
A key component of R operations on vectors is the idea of "vectorization". In essence, this means that operations between multiple R vectors will tend to recycle elements in the smaller object to the size of the larger object. This is most easily seen in vector algebra:
```{r}
# Add two vectors of equal length
1:5 + 21:25

# Add two vectors where one is a multiple of the other
1:10 + 1:2

# Add two vectors where one is not the multiple of the other
1:10 + 1:3
```

Vectorization can be used in logical indexing too
```{r}
# Select every other element
x <- 1:10
x[c(T, F)]

# Select every third element
x[c(T, F, F, F)]
```

## Character vectors
```{r}
x <- c("A", "b", "C")
x[2]

# Add names with vector
y <- 1:3
names(y) <- x

# Select using logical
x[x == "C"]

x[x != "b"]

# Index one vector with another
x[y == 2]

# Two special values that provide a vector of lower and upper case letters:
letters
LETTERS
```

## Logical vectors
```{r}
x <- c(T, F, T, F, F, T)
any(x)
all(x)

# Negate the vector
!x

# Every other value
x[c(F, T)]

# Just the TRUE values
x[x]

# Logical vectorization
x & T
x | c(F, T)
```


## Factors
Factors are special vectors where the unique values are stored as numbers and mapped to character levels

```{r}
x <- factor(c("yellow", "blue", "green", "blue", "Blue", "yellow"))
x

# Notice that the values are numerics
str(x)

# ... but the class isn't
is.numeric(x)

# ... nor is it character
is.character(x)

# Here's the class
class(x)

# and the storage mode
mode(x)
```

The numeric and original character vectors can be obtained by **coercion** using the `as.<class>` set of functions:
```{r}
as.numeric(x)
as.character(x)
```

A factor has both `levels` and `labels`. The `levels` are the set of values that might have existed in the original vector and the `labels` are the representations of the `levels`. 
```{r}
# The sample function takes a random sample from a vector with or without replacement
x <- sample(x = letters[1:4], size = 10, replace = TRUE)
xf <- factor(x)
xf

# Here are the levels
levels(xf)

# We can change the order of the levels (note doesn't change order of values in vector)
xf.lvl <- factor(x, levels = c("c", "b", "d", "a"))
xf.lvl

# Adding a level that doesn't exist has no effect on data, but includes level in list of levels
xf.lvl <- factor(x, levels = c("c", "e", "b", "d", "a"))
xf.lvl

# Omitting a level causes all values with that level to be NA
xf.lvl <- factor(x, levels = c("b", "d", "a"))
xf.lvl

# Labels will match order of levels
xf.lbl <- factor(x, labels = c("Z", "Y", "X", "W"))
xf.lbl

# But you must have as many labels as levels
xf.lbl <- factor(x, labels = c("Z", "Y", "X"))
```